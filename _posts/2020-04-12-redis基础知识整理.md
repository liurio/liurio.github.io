---
logout: post
title: redis基础知识整理
tags: [redis,all]
---

## redis数据结构

- string
- hash
- list
- set
- zset(有序集合)

## 多路复用IO模型

- 模型介绍

Redis服务器通过socket（套接字）与客户端或其他Redis服务器进行连接，而文件事件就是服务器对socket操作的抽象。服务器与客户端或其他服务器的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作。

![img](https://pics0.baidu.com/feed/342ac65c1038534379c9d8459267c57bcb8088cd.png?token=60028549915757e9b5c5f8a5b4bd6f4b&s=1AAA742329D74CCA4CD4F4C20300A0B1)

关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功，写操作类似。

操作系统的这个功能是通过select/poll/epoll/kqueue之类的系统调用函数来实现，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的**“多路”指的是多个网络连接，“复用”指的是复用同一个Redis处理线程。**

采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 I/O 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，所有 Redis 具有很高的吞吐量。

- 具体做法

用一个线程将这一万个建立成功的链接陆续的放入 event_poll，event_poll 会为这一万个长连接注册回调函数，当某一个长连接准备就绪后（建立建立成功、数据读取完成等），就会通过回调函数写入到 event_poll 的就绪队列 rdlist 中，这样这个单线程就可以通过读取 rdlist 获取到需要的数据

![img](http://p1.pstatp.com/large/pgc-image/a2eada5a14e9463185acf22b4b9ae8ef)

## redis持久化AOF和RDB

redis持久化AOF和RDB https://www.toutiao.com/i6793317264385901060/

## redis存在的问题

### 缓存穿透

key对应的数据在redis中查询不到，就会去查询数据库，但是如果数据库中也没有该记录。这样每次都不会缓存到redis。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。

#### 解决办法

##### 采用布隆过滤器

###### 布隆过滤器的结构

![img](https://upload-images.jianshu.io/upload_images/2785001-07e149c32a2608fa.jpg)

布隆过滤器是一个 bit 向量或者说 bit 数组，位数组就是数组的每个元素都只占用 1 bit 。每个元素只能是 0 或者 1。这样申请一个 10000 个元素的位数组只占用 10000 / 8 = 1250 B 的空间。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：

![img](https://upload-images.jianshu.io/upload_images/2785001-12449becdb038afd.jpg)

Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：

![img](https://upload-images.jianshu.io/upload_images/2785001-802577f6332d76b4.jpg)

值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。

###### 如何选择哈希函数的个数和布隆过滤器的长度

很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。

如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。

![img](https://upload-images.jianshu.io/upload_images/2785001-675967d74620371f.png)

##### redis中的布隆过滤器

redis4.0版本之后提供了布隆过滤器的功能。基本由两个命令`bf.add`和`bf.exists`

> bf.add : 添加元素到布隆过滤器中
>
> bf.exists: 判断某个元素是否在过滤器中

- 使用推荐

在使用`df.add`添加元素之前，使用`bf.reserve`命令创建一个自定义的布隆过滤器。该命令有三个参数

> - key
> - error_rate: 期望错误率，期望错误率越低，需要的空间就越大。
> - capacity: 初始容量，当实际元素的数量超过这个初始化容量时，误判率上升。

```bash
> bf.reserve one-more-filter 0.0001 1000000
> bf.add one-more-filter fans1
> bf.exists one-more-filter fans1
```

##### 将空结果缓存到redis

如果redis和数据库都查询不到时，将空结果插入到redis，可以把缓存失效时间设置的短一些。

### 缓存击穿

是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

#### 解决办法

设置锁，如setnx [redis分布式锁](https://liurio.github.io/2020/02/17/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/)

### 缓存雪崩

缓存雪崩与缓存击穿的区别是，缓存雪崩有多个key同时失效。

#### 解决办法

- 设置锁，如setnx
- 缓存数据的过期时间设置为随机，可以在原有的过期时间上加上一个随机值，比如1-3min，防止同一时间大量缓存数据集体失效，导致数据库压力过大。也可以根据不同的数据设置不同的因子。

https://zhuanlan.zhihu.com/p/43263751